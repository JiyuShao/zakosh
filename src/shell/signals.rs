use errno::{errno, set_errno};
use log::{debug, error};
use nix::sys::signal;
use nix::sys::wait::{waitpid, WaitPidFlag as WF, WaitStatus as WS};
use nix::unistd::Pid;
use std::collections::{HashMap, HashSet};
use std::sync::Mutex;
use std::{fmt, mem};

lazy_static! {
    static ref REAP_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
    static ref STOP_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
    static ref CONT_MAP: Mutex<HashSet<i32>> = Mutex::new(HashSet::new());
    static ref KILL_MAP: Mutex<HashMap<i32, i32>> = Mutex::new(HashMap::new());
}

pub fn disable_signals() {
    unsafe {
        // shell 进程忽略这些信号
        libc::signal(libc::SIGINT, libc::SIG_IGN); // Ctrl-C
        libc::signal(libc::SIGQUIT, libc::SIG_IGN); // Ctrl-\
        libc::signal(libc::SIGTSTP, libc::SIG_IGN); // Ctrl-Z
        libc::signal(libc::SIGTTOU, libc::SIG_IGN); // 当后台进程尝试写入终端时不暂停进程
        libc::signal(libc::SIGTTIN, libc::SIG_IGN); // 当后台进程尝试从终端读取输入时不暂停进程
    }
}

pub fn enable_signals() {
    unsafe {
        // 子进程恢复默认的信号处理
        libc::signal(libc::SIGINT, libc::SIG_DFL); // Ctrl-C
        libc::signal(libc::SIGQUIT, libc::SIG_DFL); // Ctrl-\
        libc::signal(libc::SIGTSTP, libc::SIG_DFL); // Ctrl-Z
        libc::signal(libc::SIGTTOU, libc::SIG_DFL); // 当后台进程尝试写入终端时暂停进程
        libc::signal(libc::SIGTTIN, libc::SIG_DFL); // 当后台进程尝试从终端读取输入时暂停进程
    }
}

pub fn give_terminal_to(gid: i32) -> bool {
    unsafe {
        debug!("正在将终端控制权交给进程组: {}", gid);
        let mut mask: libc::sigset_t = mem::zeroed();
        let mut old_mask: libc::sigset_t = mem::zeroed();

        libc::sigemptyset(&mut mask);
        libc::sigaddset(&mut mask, libc::SIGTSTP);
        libc::sigaddset(&mut mask, libc::SIGTTIN);
        libc::sigaddset(&mut mask, libc::SIGTTOU);
        libc::sigaddset(&mut mask, libc::SIGCHLD);

        let rcode = libc::pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
        if rcode != 0 {
            error!("failed to call pthread_sigmask");
        }
        let rcode = libc::tcsetpgrp(1, gid);
        let given;
        if rcode == -1 {
            given = false;
            let e = errno();
            let code = e.0;
            error!("error in give_terminal_to() {}: {}", code, e);
        } else {
            given = true;
        }
        let rcode = libc::pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
        if rcode != 0 {
            error!("failed to call pthread_sigmask");
        }
        given
    }
}

pub fn block_child_signals() {
    let mut sigset = signal::SigSet::empty();
    sigset.add(signal::SIGCHLD);
    match signal::sigprocmask(signal::SigmaskHow::SIG_BLOCK, Some(&sigset), None) {
        Ok(_) => {}
        Err(e) => {
            error!("sigprocmask block error: {:?}", e);
        }
    }
}

pub fn unblock_child_signals() {
    let mut sigset = signal::SigSet::empty();
    sigset.add(signal::SIGCHLD);
    match signal::sigprocmask(signal::SigmaskHow::SIG_UNBLOCK, Some(&sigset), None) {
        Ok(_) => {}
        Err(e) => {
            error!("sigprocmask unblock error: {:?}", e);
        }
    }
}

#[allow(unreachable_patterns)]
pub fn waitpidx(wpid: i32, block: bool) -> WaitStatus {
    let options = if block {
        Some(WF::WUNTRACED | WF::WCONTINUED)
    } else {
        Some(WF::WUNTRACED | WF::WCONTINUED | WF::WNOHANG)
    };
    match waitpid(Pid::from_raw(wpid), options) {
        Ok(WS::Exited(pid, status)) => {
            let pid = i32::from(pid);
            WaitStatus::from_exited(pid, status)
        }
        Ok(WS::Stopped(pid, sig)) => {
            let pid = i32::from(pid);
            WaitStatus::from_stopped(pid, sig as i32)
        }
        Ok(WS::Continued(pid)) => {
            let pid = i32::from(pid);
            WaitStatus::from_continuted(pid)
        }
        Ok(WS::Signaled(pid, sig, _core_dumped)) => {
            let pid = i32::from(pid);
            WaitStatus::from_signaled(pid, sig as i32)
        }
        Ok(WS::StillAlive) => WaitStatus::empty(),
        Ok(_others) => {
            // this is for PtraceEvent and PtraceSyscall on Linux,
            // unreachable on other platforms.
            WaitStatus::from_others()
        }
        Err(e) => WaitStatus::from_error(e as i32),
    }
}

// 监听子进程状态
extern "C" fn handle_sigchld(_sig: i32) {
    let saved_errno = errno();
    loop {
        let status = waitpidx(-1, false);

        if status.is_exited() {
            insert_reap_map(status.get_pid(), status.get_status());
        } else if status.is_stopped() {
            insert_stopped_map(status.get_pid());
        } else if status.is_continued() {
            // NOTE: SIGCHLD generated by SIGCONT is not reliable
            // on Mac (both for signal handler or sync waitpid).
            insert_cont_map(status.get_pid());
        } else if status.is_signaled() {
            killed_map_insert(status.get_pid(), status.get_signal());
        } else if status.is_error() {
            if status.get_errno() != nix::Error::ECHILD {
                error!("chld waitpid error: {:?}", status.get_errno());
            }
            break;
        } else if status == WaitStatus::empty() {
            break;
        }
    }

    set_errno(saved_errno);
}

pub fn setup_sigchld_handler() {
    let sigset = signal::SigSet::empty();
    let handler = signal::SigHandler::Handler(handle_sigchld);
    // automatically restart system calls interrupted by this signal handler
    let flags = signal::SaFlags::SA_RESTART;
    let sa = signal::SigAction::new(handler, flags, sigset);
    unsafe {
        match signal::sigaction(signal::SIGCHLD, &sa) {
            Ok(_) => {}
            Err(e) => {
                error!("sigaction error: {:?}", e);
            }
        }
    }
}

pub fn killed_map_insert(pid: i32, sig: i32) {
    if let Ok(mut m) = KILL_MAP.try_lock() {
        m.insert(pid, sig);
    }
}

pub fn killed_map_pop(pid: i32) -> Option<i32> {
    if let Ok(mut m) = KILL_MAP.try_lock() {
        m.remove(&pid)
    } else {
        None
    }
}

pub fn insert_cont_map(pid: i32) {
    if let Ok(mut m) = CONT_MAP.try_lock() {
        m.insert(pid);
    }
}

pub fn pop_cont_map(pid: i32) -> bool {
    match CONT_MAP.try_lock() {
        Ok(mut m) => m.remove(&pid),
        Err(_) => false,
    }
}

pub fn insert_stopped_map(pid: i32) {
    if let Ok(mut m) = STOP_MAP.try_lock() {
        m.insert(pid);
    }
}

pub fn pop_stopped_map(pid: i32) -> bool {
    match STOP_MAP.try_lock() {
        Ok(mut m) => m.remove(&pid),
        Err(_) => false,
    }
}

pub fn insert_reap_map(pid: i32, status: i32) {
    if let Ok(mut m) = REAP_MAP.try_lock() {
        m.insert(pid, status);
    }
}

pub fn pop_reap_map(pid: i32) -> Option<i32> {
    match REAP_MAP.try_lock() {
        Ok(mut m) => m.remove(&pid),
        Err(_) => None,
    }
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct WaitStatus(i32, i32, i32);

impl WaitStatus {
    pub fn from_exited(pid: i32, status: i32) -> Self {
        WaitStatus(pid, 0, status)
    }

    pub fn from_signaled(pid: i32, sig: i32) -> Self {
        WaitStatus(pid, 1, sig)
    }

    pub fn from_stopped(pid: i32, sig: i32) -> Self {
        WaitStatus(pid, 2, sig)
    }

    pub fn from_continuted(pid: i32) -> Self {
        WaitStatus(pid, 3, 0)
    }

    pub fn from_others() -> Self {
        WaitStatus(0, 9, 9)
    }

    pub fn from_error(errno: i32) -> Self {
        WaitStatus(0, 255, errno)
    }

    pub fn empty() -> Self {
        WaitStatus(0, 0, 0)
    }

    pub fn is_error(&self) -> bool {
        self.1 == 255
    }

    pub fn is_others(&self) -> bool {
        self.1 == 9
    }

    pub fn is_signaled(&self) -> bool {
        self.1 == 1
    }

    pub fn get_errno(&self) -> nix::Error {
        nix::Error::from_raw(self.2)
    }

    pub fn is_exited(&self) -> bool {
        self.0 != 0 && self.1 == 0
    }

    pub fn is_stopped(&self) -> bool {
        self.1 == 2
    }

    pub fn is_continued(&self) -> bool {
        self.1 == 3
    }

    pub fn get_pid(&self) -> i32 {
        self.0
    }

    fn _get_signaled_status(&self) -> i32 {
        self.2 + 128
    }

    pub fn get_signal(&self) -> i32 {
        self.2
    }

    pub fn get_name(&self) -> String {
        if self.is_exited() {
            "Exited".to_string()
        } else if self.is_stopped() {
            "Stopped".to_string()
        } else if self.is_continued() {
            "Continued".to_string()
        } else if self.is_signaled() {
            "Signaled".to_string()
        } else if self.is_others() {
            "Others".to_string()
        } else if self.is_error() {
            "Error".to_string()
        } else {
            format!("unknown: {}", self.2)
        }
    }

    pub fn get_status(&self) -> i32 {
        if self.is_exited() {
            self.2
        } else {
            self._get_signaled_status()
        }
    }
}

impl fmt::Debug for WaitStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut formatter = f.debug_struct("WaitStatus");
        formatter.field("pid", &self.0);
        let name = self.get_name();
        formatter.field("name", &name);
        formatter.field("ext", &self.2);
        formatter.finish()
    }
}
